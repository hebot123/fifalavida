/**
 * TICKET ENGINE (UPDATED)
 * Reads the static JSON file generated by your GitHub Action.
 */
const TicketEngine = {
    listings: [],
    // POINT TO THE STATIC FILE generated by your workflow
    apiEndpoint: './data/live-listings.json', 
    
    state: {
        loading: false,
        error: null,
        filter: { country: '', city: '', team: '', round: '', category: '' },
        sort: 'matchNo',
    },

    init: async () => {
        await TicketEngine.fetchListings();
        TicketEngine.populateFilters();
        TicketEngine.render();
        
        document.querySelectorAll('.ticket-filter').forEach(select => {
            select.addEventListener('change', (e) => {
                TicketEngine.state.filter[e.target.dataset.filterType] = e.target.value;
                TicketEngine.render();
            });
        });

        const sortSelect = document.getElementById('ticket-sort-select');
        if(sortSelect) {
            sortSelect.addEventListener('change', (e) => {
                TicketEngine.state.sort = e.target.value;
                TicketEngine.render();
            });
        }
    },

    fetchListings: async () => {
        TicketEngine.state.loading = true;
        TicketEngine.renderLoadingState();

        try {
            // Fetch the static JSON file
            // We add a timestamp query param (?t=...) to prevent browser caching
            const response = await fetch(`${TicketEngine.apiEndpoint}?t=${new Date().getTime()}`);
            
            if (!response.ok) throw new Error(`Data not found: ${response.status}`);
            
            const rawData = await response.json();
            
            // --- UPDATED LOGIC: Handle new API structure ---
            let items = [];
            if (Array.isArray(rawData)) {
                items = rawData;
            } else if (Array.isArray(rawData.items)) {
                items = rawData.items;
            } else if (Array.isArray(rawData.listings)) {
                items = rawData.listings; // <--- This is likely what the new API uses
            } else if (Array.isArray(rawData.data)) {
                items = rawData.data;
            } else {
                console.warn("TicketEngine: Could not find array in data", rawData);
                throw new Error("Invalid data structure");
            }
            
            TicketEngine.listings = items.map(item => {
                // Mapping fallback: Try to find data in different common fields
                const title = item.title || item.name || "Unknown Match";
                const matchNo = item.matchNumber || (title.match(/M(\d+)/) ? parseInt(title.match(/M(\d+)/)[1]) : 0);
                
                return {
                    id: item.id || `listing-${Math.random()}`,
                    matchNo: matchNo,
                    matchLabel: title,
                    date: item.matchDate || item.date || "TBD",
                    city: item.city || (item.venue ? item.venue.city : "TBD"),
                    stadium: item.stadium || (item.venue ? item.venue.name : "TBD"),
                    country: item.country || "TBD",
                    round: item.stage || item.phase || "Group Stage",
                    category: item.category || "General",
                    faceValue: item.faceValue || 0,
                    volumeUsd: item.volume || item.totalVolume || 0,
                    volumeSales: item.salesCount || 0,
                    lastSale: item.lastSalePrice || 0,
                    lastSaleDate: item.lastSaleDate || "N/A",
                    startingPrice: item.price || item.lowestAsk || item.minPrice || 0,
                    teams: item.teams || [],
                    fifaCollectUrl: `https://collect.fifa.com/marketplace/${item.id}`
                };
            });

            console.log(`TicketEngine: Loaded ${TicketEngine.listings.length} listings from static cache.`);

        } catch (error) {
            console.warn("TicketEngine: Could not load live data, using demo.", error);
            TicketEngine.state.error = "Data sync pending. Showing demo data.";
            TicketEngine.generateMockData(); // Keep fallback so the page is never empty
        } finally {
            TicketEngine.state.loading = false;
            TicketEngine.render();
        }
    },

    // --- FALLBACK MOCK DATA ---
    generateMockData: () => {
        TicketEngine.listings = Array.from({length: 10}, (_, i) => ({
            id: `mock-${i}`,
            matchNo: i + 1,
            matchLabel: "Demo Match (Live Data Failed)",
            startingPrice: 100 + i * 10,
            city: "Mexico City",
            stadium: "Estadio Azteca",
            country: "Mexico",
            round: "Group Stage",
            category: "Cat 1",
            faceValue: 200,
            volumeUsd: 5000,
            volumeSales: 20,
            lastSale: 120,
            lastSaleDate: "1h ago",
            teams: ["Mexico", "USA"],
            fifaCollectUrl: "#"
        }));
    },

    // --- RENDERING HELPERS ---
    renderLoadingState: () => {
        const tbody = document.getElementById('ticket-table-body');
        if(tbody) tbody.innerHTML = `<tr><td colspan="9" class="p-12 text-center text-emerald-400 animate-pulse font-mono uppercase">Syncing latest prices...</td></tr>`;
    },

    populateFilters: () => {
        const populateSelect = (id, items) => {
            const sel = document.getElementById(id);
            if(!sel) return;
            const current = sel.value;
            sel.innerHTML = `<option value="">All</option>`;
            items.filter(Boolean).sort().forEach(item => {
                const opt = document.createElement('option');
                opt.value = item;
                opt.innerText = item;
                sel.appendChild(opt);
            });
            sel.value = current;
        };

        const cities = [...new Set(TicketEngine.listings.map(l => l.city))];
        const countries = [...new Set(TicketEngine.listings.map(l => l.country))];
        const teams = [...new Set(TicketEngine.listings.flatMap(l => l.teams || []))];
        const rounds = [...new Set(TicketEngine.listings.map(l => l.round))];
        const cats = [...new Set(TicketEngine.listings.map(l => l.category))];

        populateSelect('filter-country', countries);
        populateSelect('filter-city', cities);
        populateSelect('filter-team', teams);
        populateSelect('filter-round', rounds);
        populateSelect('filter-category', cats);
    },

    render: () => {
        const tbody = document.getElementById('ticket-table-body');
        const countSpan = document.getElementById('ticket-count');
        if (!tbody) return;

        // 1. Filter
        let result = TicketEngine.listings.filter(row => {
            const f = TicketEngine.state.filter;
            if (f.country && row.country !== f.country) return false;
            if (f.city && row.city !== f.city) return false;
            if (f.team && (!row.teams || !row.teams.includes(f.team))) return false;
            if (f.round && row.round !== f.round) return false;
            if (f.category && row.category !== f.category) return false;
            return true;
        });

        // 2. Sort
        const s = TicketEngine.state.sort;
        result.sort((a, b) => {
            if (s === 'priceAsc') return a.startingPrice - b.startingPrice;
            if (s === 'priceDesc') return b.startingPrice - a.startingPrice;
            if (s === 'lastSale') return b.lastSale - a.lastSale;
            if (s === 'volume') return b.volumeUsd - a.volumeUsd;
            return a.matchNo - b.matchNo;
        });

        // 3. Update Count
        if (countSpan) countSpan.innerText = `${result.length} Listings ${TicketEngine.state.error ? '(Demo Mode)' : ''}`;

        // 4. Build HTML
        if (result.length === 0) {
            tbody.innerHTML = `<tr><td colspan="9" class="p-8 text-center text-gray-500">No tickets found matching your filters.</td></tr>`;
            return;
        }

        tbody.innerHTML = result.map(row => `
            <tr class="border-b border-white/5 hover:bg-white/5 transition group">
                <td class="p-4 text-emerald-400 font-mono font-bold">#${row.matchNo}</td>
                <td class="p-4">
                    <div class="font-bold text-white">${row.matchLabel}</div>
                    <div class="text-xs text-gray-500">${row.date}</div>
                </td>
                <td class="p-4">
                    <div class="text-gray-300">${row.city}</div>
                    <div class="text-xs text-gray-500">${row.stadium}</div>
                </td>
                <td class="p-4 text-sm text-gray-400">${row.round}</td>
                <td class="p-4"><span class="bg-white/10 px-2 py-1 rounded text-xs uppercase tracking-widest text-gray-300">${row.category}</span></td>
                <td class="p-4 text-sm text-gray-400">$${row.faceValue}</td>
                <td class="p-4">
                    <div class="text-gray-300">$${row.volumeUsd.toLocaleString()}</div>
                    <div class="text-xs text-gray-500">${row.volumeSales} sales</div>
                </td>
                <td class="p-4">
                    <div class="text-emerald-400 font-bold">$${row.lastSale}</div>
                    <div class="text-xs text-gray-500">${row.lastSaleDate}</div>
                </td>
                <td class="p-4">
                    <a href="${row.fifaCollectUrl}" target="_blank" class="inline-flex items-center gap-2 bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded font-bold text-sm uppercase transition">
                        $${row.startingPrice} <i data-lucide="external-link" class="w-3 h-3"></i>
                    </a>
                </td>
            </tr>
        `).join('');

        if(window.lucide) window.lucide.createIcons();
    }
};